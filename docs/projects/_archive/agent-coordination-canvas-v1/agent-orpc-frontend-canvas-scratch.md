# Agent Scratch: oRPC Frontend + React Flow Integration

## Mission
Map how the canvas and the micro-frontend host consume coordination data today, then scope an oRPC-first client surface that keeps the React Flow authoring experience intact while introducing typed hooks, shared contracts, and a plugin lifecycle from scaffold to runtime.

## Current frontend/micro-frontend API consumption
- `/coordination` (``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/coordination/components/CoordinationPage.tsx``) renders the Inngest/React Flow canvas backed by ``useWorkflow`` and ``useRunStatus``. ``useWorkflow`` currently `fetch`es `/rawr/coordination/workflows`, `/rawr/coordination/workflows/:id/validate`, `/rawr/coordination/workflows/:id/run`, and `/rawr/coordination/runs/:runId` through ``apps/web/src/ui/coordination/adapters/api-client.ts``, mapping the responses to ``CoordinationWorkflowV1``/``ValidationResultV1``/``RunStatusV1`` before updating ``activeWorkflow``/``validation``. ``useRunStatus`` polls ``getRunStatus`` and ``getRunTimeline`` and exposes ``timeline`` + ``lastRun`` for the timeline panel. ``CoordinationPage`` feeds ``workflowKitWorkflow`` (converted via ``apps/web/src/ui/coordination/adapters/workflow-mappers.ts``) into the ``Inngest`` ``Provider``/``Editor`` stack and derives ``monitorHref`` from the hard-coded ``inngestRunsUrl`` helper.
- Micro-frontend host (``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/pages/MountsPage.tsx``) ``fetch``es ``/rawr/state`` for the enabled plugin list, then dynamically ``import``s ``/rawr/plugins/web/<dirName>`` modules that implement the ``mount(el, ctx)`` contract from ``@rawr/ui-sdk``. The host currently exposes the plugin lifecycle (loading state, error badges, cleanup) but the only data surfaced to the host is the plugin list—it does not yet know about ORPC or coordination workflows.

## React Flow data contracts + ORPC hook placement
- React Flow sits behind ``workflowKitWorkflow`` (``@inngest/workflow-kit``) and the canvas components in ``apps/web/src/ui/coordination/components/canvas``. The underlying model is ``CoordinationWorkflowV1`` (``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/packages/coordination/src/types.ts``) plus derived values (``DeskDefinitionV1``, ``HandoffDefinitionV1``, ``ValidationResultV1``, ``RunStatusV1``, ``DeskRunEventV1``). ``workflow-mappers`` handles ``toCanvasWorkflow``/``fromCanvasWorkflow`` conversions, so the canvas mostly just cares about the ``WorkflowKit`` shape.
- ORPC should expose the same shapes via a contract with procedures such as ``listWorkflows()``, ``saveWorkflow(workflow)``, ``validateWorkflow(workflowId)``, ``queueRun(workflowId, input?, runId?)``, ``getRunStatus(runId)``, and ``getRunTimeline(runId)``. React Flow currently consumes ``activeWorkflow``, ``validation``, ``busy``, ``error``, ``runStatus.polling``, and ``timeline``; these values should now come from typed ORPC hooks instead of manual ``fetch`` calls. ``CoordinationPage`` also reads ``workflow.availableActions`` (``coordinationAvailableActions()``) and ``trigger`` for the provider plus ``traceLinks`` (via the stubbed ``monitorHref``) for the run panel. Those derived values stay in the page but should be fed by ORPC hook outputs (e.g., expose ``client.queueRun`` return value to compute ``monitorHref`` instead of port-locked URLs).

## Target client architecture
- **Shared contract package.** Promote the coordination types (``CoordinationWorkflowV1`` et al.) into a dedicated ORPC contract package (e.g., ``packages/coordination-contract``) that re-exports ``@rawr/coordination`` types, defines the ORPC router via ``oc.router({ ... })``, and ships Standard Schema metadata for each procedure. The contract becomes the single source of truth for both the server and client, so the frontend can ``import { coordinationContract } from '@rawr/coordination-contract'`` and reuse the same schema-driven types for inputs/outputs.
- **Query/mutation hooks.** Build a thin ORPC client layer under ``apps/web/src/ui/coordination/orpc`` that does the following:
  - Creates ``const coordinationClient = createORPCClient(new RPCLink({ url: '/rpc/coordination' }))`` and exposes helpers such as ``useCoordinationWorkflows`` (lists workflows + populates ``activeWorkflow``/``validation``), ``useCoordinatorRun`` (mutates via ``queueRun`` and returns the run payload), and ``useRunTimeline(runId)`` (polls ``getRunStatus`` + ``getRunTimeline`` with TanStack Query or a custom hook that reuses the ORPC schema validation).
  - Wraps the queries in reusable keys (e.g., ``const queryKeys = { workflows: ['coordination', 'workflows'], runStatus: (id) => ['coordination', 'runs', id] }``) so ``CoordinationPage``/``RunStatusPanel`` can subscribe to updates without duplicating polling/backoff logic (honoring Vercel best practices such as ``async-parallel`` for independent fetches and ``rerender-memo`` for derived state).
  - Provides ``mutate`` helpers for ``saveWorkflow`` and ``validateWorkflow`` that keep the canvas state fresh via ``onSuccess``/``setQueryData`` instead of manual ``refreshWorkflows`` loops.
- **Composition boundaries.** Limit React Flow components (``CanvasWorkspace``, ``FlowCanvas``) to purely presentational concerns; all data fetching, ORPC client wiring, and conversion to ``WorkflowKit`` should happen inside hooks/adapters. `CoordinationPage` remains the orchestration surface that wires commands, palette state, and provider props from the ORPC hooks. ``CanvasWorkspace`` only needs ``activeWorkflow``, ``workflowOptions``, ``busy``/``polling`` flags, and callback props (``onSave``, ``onValidate``, ``onRun``) that now delegate to ORPC hook mutations.

## Web plugin lifecycle for ORPC hookup (scaffold → runtime)
1. **Scaffold the plugin.** Run ``rawr plugins web create orpc-canvas`` (or manual copy from ``apps/web``) to produce a plugin directory under ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/plugins/web`` that exports ``mount(el, ctx)``. Inside the scaffold, include the shared ORPC client from ``@rawr/coordination-contract`` and configure it with ``ctx.basePath`` so RPC calls respect the host’s mount point.
2. **Compose the canvas.** Port the coordination UI into the plugin: import ``CanvasWorkspace``/``RunStatusPanel``/``Palette`` components, wire them to the ORPC hooks, and ensure the plugin renders the Inngest ``Provider`` stack inside the plugin root. Exported ``mount`` should append the plugin’s root node to the DOM and return a cleanup function tied to ``Provider``/``mount`` lifecycles.
3. **Bundle and register.** Build the plugin (``bun run rawr plugins web build``) so the runtime artifact lives under ``plugins/web/<dir>/dist/web.js`` and registers via ``/rawr/plugins/web/<dir>``. During ``MountsPage`` startup, the host fetches ``/rawr/state`` to discover the plugin ID, dynamically imports the built JS, and mounts it in the card list. The plugin’s ``ctx.hostAppId``/``ctx.basePath`` values let it configure the ORPC ``RPCLink`` base URL without hard-coding ``localhost`` ports.
4. **Runtime monitoring.** The plugin should surface run trace links (via ORPC responses) to replace the current ``inngestRunsUrl`` helper. ``MountsPage`` already handles re-mounting/unmounting; once ORPC becomes the canonical data plane, add readiness badges or error counters tied to ORPC client events (e.g., network failures) so the host page can warn when coordination data is stale.

## File-level change scope
1. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/coordination/adapters/api-client.ts`` – remove manual ``fetch`` plumbing and replace with ORPC client calls (list, save, run, status, timeline) so the React Flow hooks no longer duplicate response normalization.
2. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/coordination/hooks/useWorkflow.ts`` + ``.../useRunStatus.ts`` – rewrite to use ORPC queries/mutations (TanStack Query or a shared polling hook), keep ``workflowKitWorkflow`` conversions, and compute ``busy``/``polling``/``error`` from ORPC state instead of manual ``setBusy`` wrappers.
3. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/coordination/components/CoordinationPage.tsx`` – update command palette handlers to call the ORPC mutations, derive ``monitorHref`` from ``RunStatusV1.traceLinks``, and drop the temporary ``inngestRunsUrl`` helper.
4. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/pages/MountsPage.tsx`` – ensure the host can surface plugin readiness/polling state for the new ORPC plugin, possibly by shipping an ORPC-specific badge or by passing ``ctx.basePath`` into each dynamic import so plugins know the RPC endpoint.
5. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/server/src/coordination.ts`` + ``.../rawr.ts`` – introduce ``@orpc/server`` ``implement(contract)`` wiring while keeping the old REST routes for the transition; add ``RPCHandler`` (``/rpc/coordination``) and optionally ``OpenAPIHandler`` (``/api/coordination``) that reuse the existing helpers (``ensureCoordinationStorage``, ``queueCoordinationRunWithInngest``).
6. ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/packages/coordination/src/types.ts`` (or a new ``packages/coordination-contract``) – export the ORPC contract schemas so both server and client import the same types rather than duplicating Zod/JSON Schema logic.
7. New plugin scaffolding under ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/plugins/web/<orpc-canvas>`` – hosts the servable JS bundle that ``MountsPage`` “mounts” and encodes the ORPC-driven canvas so we can iterate on the canvas in isolation from the host shell.

## Tests
- ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/server/test/rawr.test.ts`` – add contract-level coverage for each ORPC procedure, mirror the old REST status cases, and assert that ``queueCoordinationRunWithInngest`` still generates ``RunStatusV1.traceLinks`` on failure/ success.
- ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/test/coordination.visual.test.ts`` – update the Playwright route mocks to cover ``/rpc/coordination``/``OpenAPI`` responses and ensure the palette/timeline states still render once the ORPC client is live.
- New contract test suite under ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/packages/coordination-contract/test`` – use ``@orpc/client/testing`` (or Vitest + ORPC client) to validate input sanitization (``isSafeCoordinationId``), response rounding, and that ``queueRun`` still delegates to the runtime adapter for timeline persistence.
- Keep ``/Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/packages/coordination-inngest/test/inngest-adapter.test.ts`` unchanged but point it at the new ORPC-backed helpers to ensure ``RunStatusV1`` semantics stay steady.

## Risks
1. Input validation drift – the current REST routes sanitize ``workflowId``/``runId`` with ``isSafeCoordinationId``; the ORPC contract must reproduce those Standard Schema constraints or we risk allowing unsafe IDs through the queue/validate procedures.
2. Polling/backoff behavior – ``useRunStatus`` currently controls ``pollRunUntilTerminal`` with custom jitter/backoff. Rebuilding that logic on top of ORPC + TanStack Query requires preserving the adaptive polling so the timeline panel still reaches terminal states without hammering the server.
3. Plugin bundling/runtime – the host assumes each plugin exposes ``mount``/``unmount`` and is fetched from ``/rawr/plugins/web/<dir>``; a new ORPC plugin must ensure its build output matches that path and that the ORPC client inside the plugin receives the correct ``ctx.basePath`` so it does not hard-code ``localhost:3000``.
4. Trace link availability – ``monitorHref`` currently points to ``http://localhost:8288/runs``; once we rely on ORPC-run responses for trace links, a bug in ``queueRun``/``RunStatusV1.traceLinks`` could leave the UI without a monitoring target.

## Source pointers
- /Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/docs/projects/agent-coordination-canvas-v1/agent-orpc-inngest-scratch.md
- /Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/coordination/hooks/useWorkflow.ts
- /Users/mateicanavra/Documents/.nosync/DEV/worktrees/wt-agent-a-coordination-design-data-v1/apps/web/src/ui/pages/MountsPage.tsx

Skills introspected: /Users/mateicanavra/.codex-rawr/skills/react-flow/SKILL.md; /Users/mateicanavra/.codex-rawr/skills/orpc/SKILL.md; /Users/mateicanavra/.codex-rawr/skills/architecture/SKILL.md; /Users/mateicanavra/.codex-rawr/skills/vercel-react-best-practices/SKILL.md; /Users/mateicanavra/.codex-rawr/skills/vercel-composition-patterns/SKILL.md
