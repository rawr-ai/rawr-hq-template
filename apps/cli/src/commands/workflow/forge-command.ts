import { RawrCommand } from "@rawr/core";
import { Flags } from "@oclif/core";
import path from "node:path";
import { journalId, safePreview, writeSnippet, type JournalSnippet } from "@rawr/journal";
import { recordArtifact, recordStep } from "../../lib/journal-context";
import { resolveCliEntrypoint, runStep, type StepResult } from "../../lib/subprocess";
import { findWorkspaceRoot } from "../../lib/workspace-plugins";

type ForgeStep = StepResult & { stdoutJson?: any };

export default class WorkflowForgeCommand extends RawrCommand {
  static description = "Forge a new durable command via the factory (demo: workload/note) and run tests";

  static flags = {
    ...RawrCommand.baseFlags,
    topic: Flags.string({ description: "Command topic", default: "workload" }),
    name: Flags.string({ description: "Command name", default: "note" }),
    description: Flags.string({
      description: "Generated command description",
      default: "Demo workload command generated by the RAWR command factory",
    }),
    "skip-tests": Flags.boolean({ description: "Skip bun run test", default: false }),
  } as const;

  async run() {
    const { flags } = await this.parseRawr(WorkflowForgeCommand);
    const baseFlags = RawrCommand.extractBaseFlags(flags);

    const workspaceRoot = await findWorkspaceRoot(process.cwd());
    if (!workspaceRoot) {
      const result = this.fail("Unable to locate workspace root (expected a ./plugins directory)");
      this.outputResult(result, { flags: baseFlags });
      this.exit(2);
      return;
    }

    if (!baseFlags.dryRun && !baseFlags.yes) {
      const result = this.fail("Refusing to mutate the repo without --yes", { code: "CONFIRMATION_REQUIRED" });
      this.outputResult(result, { flags: baseFlags });
      this.exit(1);
      return;
    }

    const topic = String(flags.topic);
    const name = String(flags.name);
    const description = String(flags.description);
    const skipTests = Boolean((flags as Record<string, unknown>)["skip-tests"]);

    const entrypoint = resolveCliEntrypoint();
    const commandPath = path.join(workspaceRoot, "apps", "cli", "src", "commands", topic, `${name}.ts`);
    const testPath = path.join(workspaceRoot, "apps", "cli", "test", `${topic}-${name}.test.ts`);

    const planned: ForgeStep[] = [
      {
        name: "factory",
        cmd: "bun",
        args: [
          entrypoint,
          "factory",
          "command",
          "new",
          topic,
          name,
          "--description",
          description,
          "--json",
        ],
        cwd: workspaceRoot,
        status: "planned",
      },
      {
        name: "tests",
        cmd: "bun",
        args: ["run", "test"],
        cwd: workspaceRoot,
        status: skipTests ? "skipped" : "planned",
      },
    ];

    if (baseFlags.dryRun) {
      const result = this.ok({ steps: planned, commandPath, testPath });
      this.outputResult(result, {
        flags: baseFlags,
        human: () => {
          for (const step of planned) this.log(`[dry-run] ${step.name}: ${step.cmd} ${step.args.join(" ")}`);
        },
      });
      return;
    }

    const steps: ForgeStep[] = [];
    let ok = true;

    for (const step of planned) {
      if (step.status === "skipped") {
        steps.push(step);
        recordStep({ name: step.name, status: "skip" });
        continue;
      }

      const r = runStep({
        name: step.name,
        cmd: step.cmd,
        args: step.args,
        cwd: step.cwd,
        inheritStdio: !baseFlags.json,
      });

      const { proc, ...publicStep } = r;
      const stdoutJson = tryParseJson(proc.stdout);
      steps.push({ ...publicStep, stdoutJson });

      recordStep({
        name: publicStep.name,
        status: publicStep.exitCode === 0 ? "ok" : "fail",
        durationMs: publicStep.durationMs,
        exitCode: publicStep.exitCode,
      });

      if (publicStep.exitCode !== 0) ok = false;
    }

    recordArtifact(commandPath);
    recordArtifact(testPath);

    await tryWriteForgeSnippet({
      repoRoot: workspaceRoot,
      ok,
      topic,
      name,
      commandPath,
      testPath,
    });

    const result = this.ok({ ok, steps, topic, name, commandPath, testPath });
    this.outputResult(result, {
      flags: baseFlags,
      human: () => {
        this.log(`forged: ${topic} ${name}`);
        this.log(`- ${commandPath}`);
        this.log(`- ${testPath}`);
        this.log(`ok: ${ok ? "true" : "false"}`);
      },
    });

    if (!ok) this.exit(1);
  }
}

function tryParseJson(raw: string): any | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

async function tryWriteForgeSnippet(input: {
  repoRoot: string;
  ok: boolean;
  topic: string;
  name: string;
  commandPath: string;
  testPath: string;
}): Promise<void> {
  const id = journalId();
  const ts = new Date().toISOString();
  const title = `workflow forge-command (${input.ok ? "ok" : "failed"})`;
  const body = [
    `workflow: forge-command`,
    `ok: ${input.ok ? "true" : "false"}`,
    `command: ${input.topic} ${input.name}`,
    `commandPath: ${input.commandPath}`,
    `testPath: ${input.testPath}`,
    "",
    "next:",
    `- run: rawr ${input.topic} ${input.name} --json`,
  ].join("\n");

  const snippet: JournalSnippet = {
    id: `${id}-workflow-forge-command`,
    ts,
    kind: "workflow",
    title,
    preview: safePreview(`ok=${input.ok} command=${input.topic}/${input.name}`),
    body,
    tags: ["workflow", "forge-command", input.topic, input.name],
  };

  try {
    await writeSnippet(input.repoRoot, snippet);
  } catch {
    // best-effort
  }
}

