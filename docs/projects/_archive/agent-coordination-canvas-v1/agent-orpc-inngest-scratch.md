# Agent Scratch: oRPC + Inngest Integration

Skills introspected: /Users/mateicanavra/.codex-rawr/skills/inngest/SKILL.md, /Users/mateicanavra/.codex-rawr/skills/orpc/SKILL.md, /Users/mateicanavra/.codex-rawr/skills/elysia/SKILL.md, /Users/mateicanavra/.codex-rawr/skills/architecture/SKILL.md, /Users/mateicanavra/.codex-rawr/skills/bun/SKILL.md

## Mission
Define how the existing Inngest-driven coordination canvas should ingest oRPC contracts, how the contracts mesh with Elysia + frontend consumers, and what transition path retires the current manual transport glue.

## Audit: Inngest topology, event contract, and serve endpoints
- `createCoordinationInngestFunction` (packages/coordination-inngest/src/adapter.ts) registers a single Inngest function (`coordination-workflow-runner`) that listens on the typed event `rawr/coordination.workflow.run`. The payload (`CoordinationRunEventData`) carries `{ runId, workflow, input?, baseUrl }`. The function entry point runs `queueCoordinationRunWithInngest` output through `processCoordinationRunEvent`, which records timeline events, persists `RunStatusV1`, and spins the workflow engine defined by `buildEngine`/`Engine` from `@inngest/workflow-kit`. `createInngestServeHandler` exposes the bundled handler to the Elysia app via `/api/inngest` so `inngest dev` or Inngest Cloud can deliver execution events. Server startup (`apps/server/src/rawr.ts`) composes the client + serve handler with `createCoordinationInngestFunction`, wiring the same `createCoordinationRuntimeAdapter` instance the `/rawr/coordination/*` routes use. Queueing a run happens through `queueCoordinationRunWithInngest`, which validates workflows, deduplicates using `runQueueLocks`, persists queued status, and updates trace links with the Inngest run/event identifiers returned from `client.send`.

## Manual API seams between Inngest and app/frontend layers
- `/rawr/coordination/*` (apps/server/src/coordination.ts) is the bespoke REST layer for CRUD, validation, run requests, and timeline queries; it does low-level JSON parsing, workflow validation, run ID generation, and error envelopes before handing data to the runtime adapter plus `queueCoordinationRunWithInngest`. The frontend `api-client.ts` mirrors this shape and exposes `listWorkflows`, `saveWorkflow`, `runWorkflowById`, `getRunStatus`, `getRunTimeline`, while `useWorkflow`/`useRunStatus` poll these endpoints with manual fetch/backoff logic. The coordination canvas also surfaces the manual `inngestRunsUrl` (ports 8288) and instructs users to click into the raw Inngest runs page, so the UI leans on bespoke URL manipulation in `CoordinationPage.tsx`. `inngest dev` uses `/api/inngest` (scripts/dev/up.sh) to drive actual execution, so the only Inngest-facing surface is this raw fetch handler and the runtime adapter; every other integration surface (workflow control + monitoring) is custom REST + fetch wrappers.

## Target oRPC integration pattern
- Introduce a `coordination` contract (monorepo package) that re-exports `CoordinationWorkflowV1` + `RunStatusV1` schemas and defines procedures: `listWorkflows()`, `saveWorkflow(workflow)`, `validateWorkflow(workflowId)`, `queueRun(workflowId, input?, runId?)`, `getRunStatus(runId)`, `getRunTimeline(runId)`. Each procedure’s schema mirrors the REST shapes already produced by `coordinationSuccess` and the front-end expects. Implement the contract once in `apps/server` using `implement(contract)` backed by the current helpers (e.g., `ensureCoordinationStorage`, `queueCoordinationRunWithInngest`) and mount it via both `RPCHandler` (`/rpc/coordination`) and `OpenAPIHandler` (`/api/coordination`) so CLI tooling or other systems can call the same contract.
- The frontend will switch to `createORPCClient(new RPCLink({ url: '/rpc/coordination' }))` and consume the generated hooks (or manually call the typed procedures). That means `useWorkflow`/`useRunStatus` can drop `api-client.ts` and instead call `client.listWorkflows()` etc., reducing manual fetch/parsing. TanStack Query utilities can wrap those RPC calls for polling/backoff, reusing ORPC’s built-in schema validation for request/response safety. The `queueRun` procedure will still call `queueCoordinationRunWithInngest`, so the Inngest serve endpoint remains untouched; ORPC just becomes the typed glue layer for workflow management + monitoring.
- Optionally re-export the generated OpenAPI spec so legacy scripts or external teams can keep hitting `/api/coordination` while new front-ends move to RPC. ORPC’s contract-first story also gives a single source of truth for the workflow shapes that both Elysia and the UI consume, which makes it easier to keep optional metadata (trace links, observability profile) aligned.

## Migration slices + deletion targets for legacy transport glue
1. Slice 1 – Contract scaffolding: add `packages/coordination-contract` (or similar) that houses the oRPC `coordination` contract + Standard Schema references. Implement and test procedures in `apps/server/src/coordination-orpc.ts` that delegate to the existing helpers; simultaneously keep `/rawr/coordination` routes intact and add new RPC/OpenAPI handlers to the Elysia app so nothing breaks.
2. Slice 2 – Frontend cutover: update `useWorkflow`/`useRunStatus` to call the ORPC client procedures (using TanStack Query for polling). After the UI has switched, delete `apps/web/src/ui/coordination/adapters/api-client.ts` and the manual fetch/backoff logic. Retain the REST routes for backward compatibility until downstream consumers are migrated by referencing the OpenAPI contract.
3. Slice 3 – Cleanup: once ORPC is the canonical surface, remove `/rawr/coordination/*` route handlers, the bespoke `coordinationSuccess`/`coodinationFailure` wrappers, and the manual `runWorkflowById` plumbing. The deletion targets are `apps/server/src/coordination.ts` (since the RPC implementation replaces it), `apps/web/src/ui/coordination/adapters/api-client.ts`, and the `CoordinationPage.tsx` helper `inngestRunsUrl` once the UI uses the ORPC client’s `monitorHref`. Leave `queueCoordinationRunWithInngest` intact behind ORPC.

## Reliability/security/test implications
- Reliability: `queueCoordinationRunWithInngest` already serializes same-`runId` submissions via `runQueueLocks`, persists every lifecycle event, and refreshes `RunStatusV1`/`traceLinks` for each state transition. ORPC simply delegates to it, so the same guarantees (retry caps, timeline events, `defaultTraceLinks`) stay in place. The Inngest function logs its own retries (`retries: 2`) and uses `step.run` wrappers for observability hooks.
- Security: `/api/inngest` is still the only surface exposed to Inngest Cloud; keep it behind Bun/Elysia’s usual CORS/security (no dev flag in production). The REST layer currently sanitizes runId/workflowId via `isSafeCoordinationId`; the ORPC input schemas should enforce the same constraints and return standard `Invalid` errors. Trace links still include signed `inngestBaseUrl` so teams can trace runs without leaking secrets.
- Tests: the existing `packages/coordination-inngest/test/inngest-adapter.test.ts` and `apps/server/test/rawr.test.ts` cover queueing, trace link propagation, and the serve handler, while `apps/web/test/coordination.visual.test.ts` covers UI wiring for trace links. After ORPC adoption, add contract tests (e.g., `@orpc/client/testing` or Vitest integration) to ensure each procedure validates `CoordinationWorkflowV1` and that `queueRun` still calls `queueCoordinationRunWithInngest`. Regression tests should re-use the same mock runtime adapter to keep timeline/assertions stable.

## File Pointers
1. packages/coordination-inngest/src/adapter.ts – event payloads, locking, runtime adapter, Inngest serve handler.
2. apps/server/src/coordination.ts – current REST endpoints and runtime helper usage.
3. apps/server/src/rawr.ts – wiring of the Inngest bundle + server route `/api/inngest`.
4. apps/web/src/ui/coordination/adapters/api-client.ts – manual fetch layer to replace with ORPC client.
5. apps/web/src/ui/coordination/hooks/useWorkflow.ts & useRunStatus.ts – workflow queue + polling logic.
6. scripts/dev/up.sh – `inngest dev` target and port conventions (PORT 8288).
7. docs/process/runbooks/COORDINATION_CANVAS_OPERATIONS.md – operational expectations for `/api/inngest` and dev workflow.
